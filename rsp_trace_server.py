#!/usr/bin/env python3
"""
This program implements the most important commands of gdb's Remote Serial Protocol (RSP)
while updating internal CPU state and surrounding memory based on a trace file that is
're-played' instead of actually executing instructions in simulation. The external effect
is that you can have a read-only session in gdb (i.e. exploratory w/o poking on registers
of memory) but fairly uncostrained. For instance you can:
    - observe execution instruction flow
    - setup break-points
    - inspect memory and registers
    - evaluate expressions
    - etc.

APPLICATION:

It is mostly geared towards debugging execution traces generated by simulation in batch
mode (for example a slow RTL simulation of a CPU subsystem) where an interactive
gdb session would be (potentially extrememely) slow or require a considereable setup in
comparison to the most common scenarion of running the simulation in batch mode.

Also applicable to instruction set simulators with poor debugging support which can
benefit from debugging out of a trace with more powerful tools as long as they support RSP.

Additionally as a side benefit, reverse debugging is also supported for free (see
reverse-continue and reverse-next gdb commands) which allow more freedom while inspecting
state around a specific execution point in either direction in time.

A couple of trace converters are provided as examples:
    trace_utils +---  spike_trace.py
                |--- sifive_rtl_trace.py

Each one converts from respective format to an internal version as a list of dictionary entries
More formatters can be contributed as needed.

CpuState is the base class that allows updating state information (including surronding memory)
Must be speciallized for differnt CPUs (see RiscvCpuState as an specialization) at least to define
its registers. The class also keeps surrounding memory updated

CAVEATS:

1- The amount of state kept is a rich as the trace. sifive-rtl format for instance does not include
   by default memory updates (I could be wrong), so control flow can be inspected well but querying
   variables / memory locations will give invalid information.

2- Gdb assumes the program is loaded in memory while performing a session (performs some queries) so
   a "load program.elf" is required to transfer relevant sections to remote target state.

3- gdb has native support for traces in binary format. Conversion to that format is a possible
   direction of work for the future to be explored. The current approach is simple, portable
   (RSP is supported by gdb and lldb for instance) and gets the job done with a high degree of
   functionality for the time being.

EXAMPLE SESSION:

terminal 1:
    $ ./rsp_trace_server.py spike_trace.log -f spike --port 1234
    ...
    INFO: Creating a new server
    INFO: RSP Server listening on localhost:1234

terminal 2:
    $ gdb
    (gdb) file program.elf
    (gdb) target remote localhost:1234
    (gdb) load program.elf
    (gdb) b main   <-- break at the start of main
    (gdb) c        <-- get into main
    (gdb) n        <-- next line
    (gdb) n        <-- next line
    (gdb) p var1   <-- inspect a variable
    (gdb) rn       <-- reverse-next, go back one line/step in time (see also reverse-cont/rc)
    (gdb) c        <-- continue
"""

# See LICENSE.txt

import argparse
import logging
import sys


import rsp_server as rs
import trace_utils as tu


def main():
    """driving program for rsp_trace_server"""

    class CustomHelpFormatter(argparse.HelpFormatter):
        """override help presentation"""

        def _get_help_string(self, action):
            help_ = action.help
            if action.default is not argparse.SUPPRESS:
                help_ += f" (default: {repr(action.default)})"
            return help_

    parser = argparse.ArgumentParser(
        description=(
            "Target RISC-V RSP server that navigates a"
            " trace as if it was a live CPU execution."
        ),
        formatter_class=CustomHelpFormatter,
    )
    parser.add_argument(
        "trace_file",
        type=str,
        default="",
        help="Path to the input trace file",
    )
    parser.add_argument(
        "--trace-format",
        "-f",
        choices=["spike", "sifive-rtl", "json"],
        default="json",
        help="format of the trace",
    )
    parser.add_argument(
        "--store-json",
        "-s",
        type=str,
        default="",
        help="Save converted trace to JSON for faster read-up later on",
    )
    parser.add_argument(
        "--cpu",
        "-c",
        choices=["risc-v"],
        default="risc-v",
        help="Choose CPU class",
    )
    parser.add_argument(
        "--host",
        type=str,
        default="localhost",
        help="host where to accept connections from",
    )
    parser.add_argument(
        "--port",
        "-p",
        type=int,
        default="1234",
        help="port where to accept connections on",
    )
    parser.add_argument(
        "--verbosity",
        "-v",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        default="INFO",
        help="Set the logging level",
    )

    args = parser.parse_args()

    log_level = getattr(logging, args.verbosity)
    logging.basicConfig(level=log_level, format="%(levelname)s: %(message)s")

    # read the trace
    trace = tu.read_trace(args.trace_file, args.trace_format)

    # if requested, save it in internal format as JSON, faster to read later on
    # saving is done before normalization as the this way is more readable
    if args.store_json != "":
        tu.dump_compact_json(args.store_json, trace)

    # normalize some values of the trace for easier internal processing
    # for example some values are converted from hex strings to integer
    trace = tu.normalize_trace(trace)

    # create CPU state holder based on CPU option
    if args.cpu == "risc-v":
        cpu_state = rs.RiscvCpuState()
    else:
        print("Unknown or unhandled CPU type {args.cpu}")
        sys.exit(1)

    # accept connections
    while True:
        logging.info("Creating a new server")
        server = rs.MinimalRspServer(
            trace, cpu_state, host=args.host, port=args.port
        )
        server.start()


if __name__ == "__main__":
    main()
